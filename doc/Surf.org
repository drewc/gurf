[[../troubleshooters.htm][Troubleshooters.Com]]^{®},
[[./index.htm][Linux Library]] Present:

Surf Demystified

[[../cpyright.htm][Copyright © 2017]] by Steve Litt

<<monthfea>>
See the [[http://www.troubleshooters.com/bookstore/][Troubleshooters.Com
Bookstore]].

Contents:

- [[#introduction][Introduction]]
- [[#andtabbed][Surf and Tabbed]]
- [[#surfpkgmgr][Installing Surf With a Package Manager]]
- [[#surfhotkeys][Surf Hotkeys]]
- [[#keyboardonly][Keyboard-Only Surf Usage]]
- [[#linkhints][Link Hints]]
- [[#modsurf][Modifying Surf]]
- [[#surfconfigdetails][Surf Configuration Details]]
- [[#installingtabbed][Installing Tabbed]]
- [[#cmdexpl][Explanation of Commands]]
- [[#modtabbed][Modifying Tabbed]]
- [[#mouseprimary][Mouse-primary Surf Usage]]
- [[#integration][Integrating Tabbed and Surf With Other Programs]]
- [[#sucklessadvantage][The Suckless Tools Advantage]]
- [[#acquiredtaste][Surf: An Acquired Taste]]
- [[#wrapup][Wrapup]]

* Introduction
  :PROPERTIES:
  :CUSTOM_ID: introduction
  :END:

This is a long document because it's the only /complete/ documentation
for the Surf browser. This is a necessary document because other
browsers have become so rickety that Surf has become the go-to browser
for anyone willing to use a simple, keyboard-centric interface.

Surf is a simple, lightweight browser from Suckless Tools, the same
people who brought you dmenu and dwm. When compiled and configured
right, Surf is incredibly robust and stable, able to handle most
websites extremely well, and it has a clean and simple layout without
buttons and bars to encroach on the web material you're reading.
Unfortunately, Surf is underdocumented, so most who try Surf give up
after a few minutes, moving on to Firefox or Chromium or Palemoon or
Midori. This web page serves as the needed documentation to make Surf a
pleasure to work with.

Surf gains a new credibility and significance now (2017), because in
2017, most browsers have declined in stability and performance, over the
last several years, to the point where several of them are unusable on
various distros. We all know Firefox is now skating on the edge of
uselessness, at least on several distros. Palemoon, the "lighter
Firefox", has performance problems that frequently drag the whole
computer almost to a standstill. Midori, Luakit, Xombrero and most of
the other Webkit derived browsers intermittently abort suddenly, at
least when hosted on Void Linux. I'm having some success with Chromium,
but it's piggy and often quirky. If you're anything like me, these days
browsers are exhibiting ever worsening flaws, so that ever more
frequently you need to once again switch browsers to one that sucks just
a little less than the others.

Meanwhile, over the past few years, the Surf browser has acquired CSS
and Javascript abilities, so it now renders as well as, and very
similarly to, any of the big boys. And if you run it right, it's stable:
More stable than most of the usual suspects: Especially Firefox and
Palemoon. So now, with the big boys defaulting on stability and
performance, Surf begins to look like the best of the bunch, at least
for general purpose browsing.

Of course Surf isn't perfect. I found no obvious way to use SSL with
Surf, although the source code appears to have some code related to SSL.
Maybe you can get it to work with SSL, but lacking both a URL bar and
that cool little lock icon, I wouldn't do online banking, shopping or
bill paying with Surf. Because in some environments using Surf with
plugins producing the dreaded "program vanished" Webkit bug, many folks
can't use Surf with plugins such as ad blockers. Also, the only way to
configure Surf is to recompile it, and many folks prefer to use the
version installed by their package manager. And typically, the package
manager version has small, low contrast fonts used to acquire URLs,
requiring modification by anyone with bad vision. And when you modify by
recompilation, you'll find that Surf depends on a surprising number of
other software you might not have installed.

With no URL field, no button bar, and no back button, Surf isn't
mouse-friendly without adding some [[#mouseprimary][user addable
features]] discussed toward the end of this document.

This out of the box keyboard-centricity is fine: Keyboard productivity
is much higher than mouse productivity. But Surf lacks
keyboard-accessibility in one critical browsing activity: Navigating to
and following links. So as Surf ships from the factory, you need to keep
switching from mouse to keyboard: A guaranteed productivity killer. Surf
documents a Javascript implementation of "link hinting": A functionality
by which, when invoked, all visible links are numbered and you can
follow them by typing in the number. Unfortunately, the javascript
solution Suckless Tools gives you works on some web pages and not
others. Later in this document you'll be given a 12 line piece of
Javascript that makes Surf's Javascript solution work every time. Also
given later in this document is a way to make the Grave accent key into
the equivalent of a back button, so you can keep mousing with your right
hand while easily going back in history with your left.

Surf has no URL field, so neither copying nor pasting the URL is
obvious. It does, however, have hotkeys for copying the current URL into
the clipboard (Ctrl+y), and navigating to the URL currently in the
clipboard (Ctrl+p). Surf doesn't have the handy URL completion that most
modern browsers have, and this is the one missing productivity feature
you can't make up for with creative configuration.

Surf is very, very different from most browsers. It's an acquired taste,
and most of us would prefer Firefox as it existed in 2010, or even
Galeon from 2005. But those choices are gone now: Firefox is sand
saturated molasses. So is Firefox's "lighter" little brother Palemoon,
and when hosting a few tabs with challenging web pages, both give your
computer that Windows 95 pacing from the days of the Pentium 1 with 64
*M*B of RAM. Galeon is gone, and its descendants are part of the Gnome3
universe, with Gnome (along with its FreeDesktop siblings including
systemd) becoming more of an "in for a penny, in for a pound" type
thing. It's beginning to look like Surf is the last good browser
standing.

Yes, most of us would prefer 2010 Firefox, but for the past three or
four years a lot of us have been switching browsers often -- every time
our favorite one broke. And many of us use different browsers for
different things. And I think that's where Surf comes in: A great
browser for generic web viewing and Youtube videos. For secure online
transactions you'd probably use Firefox (it works OK if used on one
website at a time) or Chromium. Or, if yours isn't one of those distros
with the webkit arbitrary abort problem, Midori, Luakit, Xombrero or any
number of other lightweight browsers work quite well. To reiterate, what
separates Surf from the other Webkit driven lightweights is that with
Surf you can fix those aborts.

Let me reiterate: Firefox and Chromium work quite well if you use them
only for online secure transactions, while offloading generic browsing,
and especially videos, to lightweight browsers like Surf. Just don't
give heavy work to Chromium, or especially Firefox.

One of the best things about Surf is its simplicity. The C code compiles
with a minimum of fuss, and missing dependencies (mostly devel packages)
are easy to deduce from compile error messages. If things get
squirrelly, you can look at the (easy) source code or change it.
Configuration is as simple as changing the config.h file and
recompiling.

If you like operating your browser from the keyboard, you're going to
love Surf. Almost everything that could be done can be done with
hotkeys, and it's quite easy to modify config.h to give yourself new
hotkeys.

Another nicety of Surf is an acquired taste: Lacking all buttons and
bars, Surf devotes every square millimeter to the content you're
viewing. It does this by offloading the functionalities of all those
buttons to hotkeys, which usually turns out to be faster than mousing
them. Use Surf for a couple weeks, then go back to Firefox, and you'll
feel like you're viewing the web through a little peep hole.

This is 2017, we're rapidly getting to the point where browsers are like
email clients: They all suck. In this environment, the Surf browser,
which sucks a lot less than the rest, takes on a new importance.

* Surf and Tabbed
  :PROPERTIES:
  :CUSTOM_ID: andtabbed
  :END:

Surf is limited to looking at one website at a time, like the browsers
from 1996. Don't worry though: With the addition of another Suckless
Tools program called Tabbed, you can have the equivalent of a tabbed
browser. The command is simple enough:

#+BEGIN_EXAMPLE
  tabbed surf -pe
#+END_EXAMPLE

The following hotkeys then control your tabbing:

- Shift+Ctrl+Enter: New tab
- Shift+Ctrl+l: Next higher number tab
- Shift+Ctrl+h: Next lower number tab
- Ctrl+Tab: Toggle between last 2 tabs
- Ctrl+1: Switch to tab 1
- Ctrl+2: Switch to tab 2
- Ctrl+3: Switch to tab 3, etc.
- Ctrl+q: Close this tab
- Ctrl+t: Tab picklist

As long as we're on the subject of hotkeys, here are a few hotkeys for
Surf survival:

- Ctrl+g: Go to URL (field on screen's upper left (not the browser
  window) opens for you to type)
- Ctrl+h: Previous page in history, like back button on other browsers
- Ctrl+r: Refresh/reload.
- Ctrl+-: Zoom out a little
- Shift+Ctrl++: Zoom in a little
- Shift+Ctrl+q: Normal zoom

** Get Surf Running First!!!
   :PROPERTIES:
   :CUSTOM_ID: get-surf-running-first
   :END:

Tabbed works well. I promise. You can have all the tabs you want in
Surf. Tabs won't be a problem.

But for your own sanity, get Surf running first, learn how to use it,
and if you're configuring it, configure it completely. You don't need
the distractions of configuring/compiling Tabbed while learning Surf.
While you're learning and setting up Surf, please remember there's no
shame in running multiple copies of Surf, each tuned to a different
website, and using your window manager's Ctrl+Tab to move between them.
Soon enough you'll install, set up and use Tabbed to zip between tabs at
the speed of light.

* Installing Surf With a Package Manager
  :PROPERTIES:
  :CUSTOM_ID: surfpkgmgr
  :END:

Try installing Surf with a package manager. It might suit your needs,
and if it does, that will save you a lot of work, because Surf has a lot
more dependencies than you might first suspect, and lack of some of
those dependencies could cause a runtime mistake (not even error, just
malfunction) rather than failure to compile. So just use your package
manager's search facility to find the package containing Surf, and use
your standard package manager install command to install it. Then run
Surf as follows:

#+BEGIN_EXAMPLE
  surf -p
#+END_EXAMPLE

Your next step is to operate Surf with its [[#surfhotkeys][hotkeys]].

* Surf Hotkeys
  :PROPERTIES:
  :CUSTOM_ID: surfhotkeys
  :END:

To kill a single instance of Surf (not run with Tabbed), just use the
Window Manager Close Window Command. Beyond that, the following comprise
the most widely used Surf hotkeys:

- Ctrl+g: Go to URL (field on screen's upper left (not the browser
  window) opens for you to type)
- Ctrl+p: Go to URL in cut and paste clipboard
- Ctrl+y: Put current website URL into cut and paste clipboard
- Ctrl+h: Previous page in history, like back button on other browsers
- Ctrl+l: Undo the last Ctrl+h (go later in history)
- Ctrl+r: Refresh/reload from cache.
- Ctrl+Shift+r: Refresh/reload /without/ cache
- Ctrl+-: Zoom out a little
- Shift+Ctrl++: Zoom in a little
- Shift+Ctrl+q: Normal zoom, and note that this might not be the zoom
  the browser opened with, if the browser was set to open with a
  non-normal zoom.
- Ctrl+o: Toggle "view source"
- Ctrl+j: Down a little
- Ctrl+k: Up a little
- Ctrl+Space: Down a lot
- Ctrl+b: Up a lot
- Ctrl+i: Scroll left a little
- Ctrl+u: Scroll right a little
- F11: Toggle fullscreen
- Shift+Ctrl+b: Toggle scrollbars
- Shift+Ctrl+g: Toggle geolocation

* Keyboard-Only Surf Usage
  :PROPERTIES:
  :CUSTOM_ID: keyboardonly
  :END:

Surf is built more for keyboard use than for the mouse. There's no back
button to click. There's no URL field to click and paste into. The
person wanting to use a mouse would be much better off with Midori than
with the standard default Surf. But if you like productivity, you like
the keyboard, and for those who like the keyboard, Surf offers a wealth
of keyboard techniques.

** Following Links From the Keyboard
   :PROPERTIES:
   :CUSTOM_ID: kbdlinks
   :END:

Surf offers two very different ways to follow links from the keyboard.
One way, link hints, is discussed in its [[#linkhints][own section]]
later in this document. The other way, using the arrow keys and Enter
key, is described in the next couple paragraphs.

The trick is to scroll with Ctrl+j or Ctrl+k till the link you want is
approximately on the top or bottom of the viewing area, then use up
arrow, down arrow, left and right to move the very thin dashed line to
the link you want. Once the link is so surrounded, press Enter and Surf
will download the page pointed to by that link. This isn't perfect. The
thin dashed line is not visible at a glance: You need to look carefully.
And it works only on text links. But in a great many cases, it gets the
job done, especially for those with great visual acuity. And remember,
you can always get [[#linkhints][link hints]] running..

** Keyboard Back Button
   :PROPERTIES:
   :CUSTOM_ID: kbdbackbutton
   :END:

Another productivity enhancer would be some sort of mouse-based "back
button", so if you already have the mouse in your right hand, you can
quickly use your left hand to tap a left-keyboard key. I personally use
the Grave accent ('`'). F2 (GDK_F2) are both excellent for moving to the
previous web page. As shipped, Surf already gives you Ctrl+Shift+l for
this purpose, but that requires you to drop and later re-grab your
mouse. With the Grave Accent, your right hand stays right on the mouse.
The grave accent is incredibly easy to hit with the left hand, but it
prevents ever typing a grave accent into a text entry field. F2 is
harder to hit quickly (and without too much looking), but it's unlikely
to conflict with any other situation. F1 is used for "help" in too many
places, and Esc has too many other usages to make it practical.

To do this, within config.h, copy the original Ctrl+r hotkey line, and
change the copy to either the Grave accent of F2. This document later
features a section on [[#modsurf][modifying the source and
recompiling]].

* Link Hints
  :PROPERTIES:
  :CUSTOM_ID: linkhints
  :END:

No Surf feature is murkier, more poorly documented, and more argued
about on the Internet than Link Hints. After reading and following the
advice in this section, Link Hints will work perfectly for you every
time.

** The Controversy
   :PROPERTIES:
   :CUSTOM_ID: the-controversy
   :END:

Some folks say Link Hints works. Others say it doesn't work. Still
others say it works on some websites and not others. The latter is the
accurate assertion, as this section will later demonstrate. But first,
the following is an example of how crazy arguments about whether it
works or not can get:

[[https://www.mail-archive.com/search?l=dev@suckless.org&q=subject:%22Re%3A+%5Bdev%5D+%5Bsurf%5D+script.js%22&o=newest&f=1]]

There are other web pages with similar back-and-forth arguments, but
they're hard to find because Surf is a common word and the Surf browser
isn't used by many people. Meanwhile, Suckless Tools' official Link
Hints page gives no indication that there's any problem at all:

[[http://surf.suckless.org/files/link_hints]]

The section you're now reading settles this once and for all, by giving
you a web page [[http://troubleshooters.com/simple_page.html]] that
doesn't work with Suckless Tools' official Link Hints Javascript code,
and giving you a 12 line Javascript addition that causes all web pages,
including [[http://troubleshooters.com/simple_page.html]], to work with
Link Hints.

** What are Link Hints
   :PROPERTIES:
   :CUSTOM_ID: what-are-link-hints
   :END:

Link Hints are numbers that appear beside every link, after you press
Ctrl+Shift+f. When you keyboard-input the number corresponding to a
link, the web page that link points to is pulled up in a new browser, or
if you're using Tabbed, a new tab. This means you can do all link work
from the keyboard: A powerful productivity advantage once you get used
to it. For the Surf browser, Link Hints are implemented in Javascript
you copy into ~/.surf/script.js.

** First Step: Install Link Hints the Suckless Way
   :PROPERTIES:
   :CUSTOM_ID: first-step-install-link-hints-the-suckless-way
   :END:

Before doing anything else, back up your existing ~/.surf/script.js, if
you have one. This procedure could mess it up, so be ready to put it
back.

The people at Suckless Tools have already written (almost) all the
Javascript for you. First, navigate to
[[http://surf.suckless.org/files/link_hints]]. Go down to the section
titled "Code". That section contains nothing but the Javascript code to
implement Link Hints. Copy that entire block of code to the clipboard.

In ~/.surf/script.js, put about 10 blank lines at the bottom, and below
those blank lines , then paste the code you copied below the 10 blank
lines, and theoretically you now have Link Hints. Test your new Link
Hints on this web page by running the following command at the command
prompt:

#+BEGIN_EXAMPLE
  surf -p http://troubleshooters.com/linux/surf.htm
#+END_EXAMPLE

This web page appears in a new browser. Now press Ctrl+Shift+f and
notice that each link (there are several at the top of this web page)
gets highlighted and acquires a number. Type in the number for one of
the links and notice a new browser appears with that link's web page.
You've proven that Surf's Link Hints work!

On    this    web    page.

Now do the same thing, but with a very simple web page:

#+BEGIN_EXAMPLE
  surf -p http://troubleshooters.com/simple_page.html
#+END_EXAMPLE

On this simple web page, press Ctrl+Shift+f, and note that nothing
happens. This is discouraging. This is what has created all the
arguments, misunderstandings, and storming off the field on the
Internet. The Link Hints given by Suckless Tools works for some web
pages, and not for others. In fact, Suckless Tools' code works for any
page that already has at least one CSS stylesheet, and fails on any web
page not containing a CSS stylesheet. Suckless Tools' Javascript inserts
CSS rules in Stylesheet 0, whether or not there is a Stylesheet 0, and
many simple web pages have no CSS, so they have no Stylesheet 0.

To see the exact location where the existence of at least one stylesheet
is assumed and acted upon, see the first lines in functions
setHintRules() and deleteHintRules().

** Second Step: Add Javascript to guarantee a stylesheet
   :PROPERTIES:
   :CUSTOM_ID: second-step-add-javascript-to-guarantee-a-stylesheet
   :END:

So I created some Javascript that adds a Stylesheet if there are no
stylesheets. Here's my Javascript:

#+BEGIN_EXAMPLE
  function guarantee_stylesheet(){
   var thehead = document.getElementsByTagName('head')[0];
   if (document.getElementsByTagName('style').length < 1){
      var thesty = document.createElement('style');
      thesty.innerHTML = thesty.innerHTML + ' div#diag_kludge{color: #0099ff;} ';
      thesty.innerHTML = thesty.innerHTML + ' div#diag_kludge{background-color: #660000;} ';
      thehead.appendChild(thesty);
      divv = document.getElementById('diag_kludge');
      titl = headd.getElementsByTagName('title')[0];
      }
  }
  window.addEventListener('load', guarantee_stylesheet, false);
#+END_EXAMPLE

So, to guarantee Link Hints on all web pages, make ten blank lines below
the current bottom of your ~/.surf/script.js file, and copy and paste
the preceding code below the ten new blank lines, and save. Now test on
a simple page:

#+BEGIN_EXAMPLE
  surf -p http://troubleshooters.com/simple_page.html
#+END_EXAMPLE

Press Ctrl+Shift+f and make sure the preceding page's one link is
numbered, and that when you enter the number of that link, a new
instance of Surf (or a new tab) appears with Troubleshooters.Com's home
page. Troubleshoot as necessary, noticing that for debugging purposes,
the preceding website actually has a div with id diag_kludge. Make sure
Link Hints still work with more complicated pages.

** Hotkey for following links directly
   :PROPERTIES:
   :CUSTOM_ID: hotkey-for-following-links-directly
   :END:

Ctrl+Shift+f follows a link into a new tab. Sometimes that's what you
want, but often it isn't. Pressing Ctrl+Shift+f to follow a series of
links leaves you with too many tabs, perhaps dozens. Usually, what you
want is to follow the link into its web page /in the current tab/.

The Link Hints javascript code you copied actually offers such a hotkey:
Ctrl+f. Unfortunately, Ctrl+f is already the hotkey for Find in Surf,
and it's an excellent hotkey for that: Both mnemonic and commonly used.
So you have to change Ctrl+f. I changed it to Ctrl+w just for ergonomic
reasons. Change it to any other key combo you want that has no other
meaning in Surf or Tabbed, but change it to something, because it's very
necessary.

** What You've Accomplished
   :PROPERTIES:
   :CUSTOM_ID: what-youve-accomplished
   :END:

What you just did was, in a paraphrase of Joe Biden, a Big Fantastic
Deal! With the addition of surefire keyboard driven Link Hits, use of
Surf exclusively through keyboard interaction becomes not only possible
but easy and productive.

** Link Hints Rules of the Road
   :PROPERTIES:
   :CUSTOM_ID: link-hints-rules-of-the-road
   :END:

Scroll then hint, not vice versa! If you scroll after Link Hinting,
you'll very likely encounter unnumbered links. But if you scroll to the
link you want (quite easy from the keyboard) and then press
Ctrl+Shift+f, all links visible on the current screen are visible, and
you can enter the desired number.

Ctrl+Shift+f is a toggle! If you're anything like me, your first
inclination when trying to turn off Link Hints will be to press the
Escape key, but this doesn't work. Turn Link Hints off the same way you
turned them off: With Ctrl+Shift+f.

** Left as Exercises For the Reader
   :PROPERTIES:
   :CUSTOM_ID: left-as-exercises-for-the-reader
   :END:

It took me a looooong time to identify the key distinction between
websites that did and didn't work with Suckless Tools' Link Hint code
(pre-existence of a stylesheet), and because I'm not the world's
greatest Javascript guy and Surf isn't the greatest Javascript
development environment, a long time to create the workaround. So I
stopped before making Link Hints perfect. You can continue the work, and
if you find how to improve it, please
[[http://troubleshooters.com/email_steve_litt.htm][email me]].

1. [[#h3_includefiles][Include files within ~/.surf/script.js]]
2. [[#h3_translinkhints][Transparent Link Hint highlighting]]
3. [[#h3_curbrows][Option to make followed link appear on current
   browser]]

*** Include files within ~/.surf/script.js
    :PROPERTIES:
    :CUSTOM_ID: h3_includefiles
    :END:

By the time you add both Suckless Tools' Link Hints javascript and my
guaranteed stylesheet addition, ~/.surf/script.js is a mess. If you've
added in your own Javascript, ~/.surf/script.js becomes very hard to
maintain. It would be nice if ~/.surf/scrpt.js looked more like the
following:

#+BEGIN_EXAMPLE
  document.write('<script src=".surf/surefire.js"  type="text/javascript"></script>');
  document.write('<script src=".surf/linkhinting.js" type="text/javascript"></script>');
#+END_EXAMPLE

However, I tried the preceding, and it didn't facilitate Link Hints when
pressing Ctrl+Shift+f, so I went on to other things and left this as an
exercise for the reader.

*** Transparent Link Hint highlighting
    :PROPERTIES:
    :CUSTOM_ID: h3_translinkhints
    :END:

The current link highlighting often obstructs the text of the link. So
you need to toggle Link Hints off, memorize the relevant links, and then
toggle Link Hints on. Not good for productivity.

Fixing this would require going into Suckless Tools' javascript code and
changing the CSS. Either the original colors must be evaluated to change
the text color to a contrast of the new background color, or perhaps
leave foreground and background alone except make the text blink. Yeah,
this is the first time I've ever recommended blink, but it might make
sense in this case.

I can use Link Hints in its current form, just toggling Link Hinting to
memorize the relevant link texts. So I leave a more readable solution as
an exercise to the reader.

*** Option to make followed link appear on current browser
    :PROPERTIES:
    :CUSTOM_ID: h3_curbrows
    :END:

Right now, following a link with Link Hints always brings up a new
browser or tab, whereas you might desire following the link in the
current browser or tab. Each has its own advantages and best situations.
I leave it as an exercise for the reader to implement this as an option.

*** Email me with solutions
    :PROPERTIES:
    :CUSTOM_ID: email-me-with-solutions
    :END:

If you manage to implement solutions for any of these suggested
improvements, please
[[http://troubleshooters.com/email_steve_litt.htm][email me]].

* Modifying Surf
  :PROPERTIES:
  :CUSTOM_ID: modsurf
  :END:

If you can use Surf as it comes from your package manager, by all means
do that, because the alternative is downloading and compiling it. Almost
all configuration requires recompilation. And compiling Surf requires
many more dependencies than you might imagine.

That being said, a few added hotkeys makes Surf much more productive.
Also, most packagers assume the world has 20/20 vision, so you might
have no choice but to modify it so you can see it. Especially obnoxious
is the tendency to make dmenu entries (Surf uses dmenu for all input)
tiny-fonted midgray on darkgray. I mean really, couldn't you have set it
up white on black or bright green or light yellow on black? Who would it
have offended? But noooooo.

So in many cases, you have no choice to compile Surf. Don't worry, it's
quite doable.

1. [[#h2_downinst][Download and install the source]]
2. [[#h2_investigate][Investigate the source files]]
3. [[#h2_usual_supects][Package install the usual suspects]]

   - [[#h3_gtkplus][gtk+ header files]]
   - [[#h3_webkitgtkplus][all webkit+gtk+ header files]]
   - [[#h3_pkg_config][pkg-config]]
   - [[#h3_dmenu][dmenu (available at]]
     [[http://suckless.org][suckless.org]] if your distro has no package
     for it)
   - [[#h3_gdb][gdb and gdb-debug (helps prevent intermittent crashes)]]

4. [[#h2_compile_script][Write a compile/run shellscript]]
5. [[#h2_keep_compiling][Keep compiling till it works]]
6. [[#h2_configure_surf][Configure Surf]]
7. [[#h2_make_install][Make install]]

** Download and install the source
   :PROPERTIES:
   :CUSTOM_ID: h2_downinst
   :END:

Download the tarball (link at bottom of [[http://surf.suckless.org/]].
Untar the tarball into a directory owned by a non-root user. You'll see
several files, including a README file.

** Investigate the source files
   :PROPERTIES:
   :CUSTOM_ID: h2_investigate
   :END:

Start by reading README, config.mk and config.def.h. Don't change any of
them unless you're using BSD or a very bizarre Linux distribution, and
not even then. The first time you compile, config.dev.h and config.mk
are consulted to create config.h, which in all but the most abnormal
cases should be the only file you modify.

As you read config.dev.h, which as you remember you do not modify,
you'll see all sorts of boolean properties, a few functions and macros,
and down toward the bottom a bunch of hotkeys and a few mouseclick
mappings to functions. It's these hotkeys and perhaps mouseclicks that
you'll spend the most time with.

Search for the string dmenu, which occurs inside a macro called SETPROP.
If, when you press Ctrl+g or Ctrl+f, the text in the input area that
opens at the top left of the screen isn't readable enough, you'll later
be changing that by adding arguments to dmenu, as later detailed in the
[[#surfconfigdetails][Surf Configuration Details]] section.

** Package install the usual suspects
   :PROPERTIES:
   :CUSTOM_ID: h2_usual_supects
   :END:

The packages you /know/ must be installed to make Surf work are the
following:

- [[#h3_gtkplus][gtk+ header files]]
- [[#h3_webkitgtkplus][all webkit+gtk+ header files]]
- [[#h3_pkg_config][pkg-config]]
- [[#h3_dmenu][dmenu (available at]]
  [[http://suckless.org][suckless.org]])
- [[#h3_gdb][gdb and gdb-debug (helps prevent intermittent crashes)]]

*** gtk+ header files
    :PROPERTIES:
    :CUSTOM_ID: h3_gtkplus
    :END:

Surf uses GTK+, so you need all the GTK+ header files, which normally
aren't installed. Search your package manager for all packages with
string "gtk+" and also containing "devel", for your architecture.

*** all webkit+gtk+ header files
    :PROPERTIES:
    :CUSTOM_ID: h3_webkitgtkplus
    :END:

What a mess. There are Webkit + GTK packages, and Webkit2 + GTK, and
Webkit + GTK2, and Webkit2 + GTK2. My experience is that if it has the
strings "webkit", "gtk" and "devel", and is a package for your
architecture (64 bit or 32 bit), you're best off to install it now. If
you happen to install an extra one, that's a lot easier than not
installing the right one(s) and having to troubleshoot. If really
needed, you can delete what you believe to be the extra one(s), one at a
time, after it's compiling, and if it continues to compile, I guess it
was extra. But if you want to get Surf compiled before New Years,
install them all at first.

*** pkg-config
    :PROPERTIES:
    :CUSTOM_ID: h3_pkg_config
    :END:

This is used by the Surf make file to configure certain packages. Even
though this package is maintained by Freedesktop.Org, it has almost no
dependencies.

*** dmenu (available at [[http://suckless.org][suckless.org]])
    :PROPERTIES:
    :CUSTOM_ID: h3_dmenu
    :END:

Surf compiles without dmenu, but you won't be able to input a URL or
search string without it. Install dmenu.

*** gdb and gdb-debug (helps prevent intermittent crashes)
    :PROPERTIES:
    :CUSTOM_ID: h3_gdb
    :END:

gdb is the Gnu Debugger. Surf runs perfectly without it. Most of the
time. But occasionally a challenging website makes it error out with a
message about not finding gdb. If you install gdb and gdb-debug, this
particular error can't happen.

** Write a compile/run shellscript
   :PROPERTIES:
   :CUSTOM_ID: h2_compile_script
   :END:

While compiling and configuring Surf, you'll do many instances of make
plus run. And you sure don't want to log in as root and do a
make install every time. So create the following shellscript to make and
run, in the current directory, as you:

#+BEGIN_EXAMPLE
  #!/bin/sh
  cd ~/compiles/surf-0.7
  rm -f ./surf
  make clean
  make
  ./surf -p ~/mybookmarks.html
#+END_EXAMPLE

The preceding script assumes your source files are in
~/compiles/surf-0.7, which is the current version on 3/9/2017. If your
Surf version is different, modify line 2 accordingly. I called my
shellscript jj, because it's very easy to type ./jj over and over again.

** Keep compiling till it works
   :PROPERTIES:
   :CUSTOM_ID: h2_keep_compiling
   :END:

Even if you followed every instruction so far in this document, I'm
betting your first compile will fail. Something always goes wrong. So
just read error messages and keep fixing the problem accordingly. The
problem is usually a package that hasn't been installed yet.

After it compiles, it probably won't work right, so you'll need to keep
tweaking and compiling it till it does. Just keep compiling again and
again until it's perfect. Each compile takes about 3 seconds, so it's no
big deal.

** Configure Surf
   :PROPERTIES:
   :CUSTOM_ID: h2_configure_surf
   :END:

Even when it works right, you'll probably want to add some custom
hotkeys, and maybe, if your vision is less than that of an eagle, add
size and contrast to some fonts, and then recompile. Keep on until it's
perfect.

** Make install
   :PROPERTIES:
   :CUSTOM_ID: h2_make_install
   :END:

When surf is exactly how you want it, it's time to install it and its
man pages in the standard way, which is in /usr/local/bin and
/usr/local/man. So perform the following command to do this:

#+BEGIN_EXAMPLE
  su -c "make install"
#+END_EXAMPLE

Or, if you have one of those distros that depends on sudo, perform the
following:

#+BEGIN_EXAMPLE
  sudo make install
#+END_EXAMPLE

After you type in the password, Surf will be installed. By the way, Surf
has an "uninstall" option for its make, if you ever need to use that.

* Surf Configuration Details
  :PROPERTIES:
  :CUSTOM_ID: surfconfigdetails
  :END:

This section details how you can configure your Surf program to your
exact needs. All the work described in this section is performed by
editing the config.h file. This section describes the setting of several
simple details, and then goes heavily into setting hotkeys, and setting
the font size of the dmenu-driven URL input field, via modifications to
the dmenu part of the SETPROP() macro.

Open up the config.h file and browse through it. At the top is the user
agent string, which is the browser which Surf is masquerading as. This
is necessary because sites created with Surf in mind are rare indeed.
Even sites created to be browser-agnostic (like the one you're now
reading), are fairly rare. After the user agent string comes some
strings representing files and directories used by Surf. Then come some
booleans affecting how Surf looks and behaves.

Then you come to the first things you're likely to modify: The default
font and zoom level. If Surf seems to render fonts and/or images too
small for your eyesight, try cranking up the zoomlevel a little bit. If
that doesn't work, maybe crank up the default font size just a smidge.
Be careful though, if you use big numbers like a 1.8 zoom level or a 22
point font, many sites will render into what looks like a junk heap, so
enlarge only as needed.

Next you come to a bunch of mostly booleans determining how webkit acts.
For the most part, you'll probably want to leave these alone. Next you
come to the SETPROP() macro, which has its own subsection within this
section.

** Hotkeys
   :PROPERTIES:
   :CUSTOM_ID: hotkeys
   :END:

Skip on down to the following line:

#+BEGIN_EXAMPLE
  #define MODKEY GDK_CONTROL_MASK
#+END_EXAMPLE

MODKEY is Surf's foundational modifier key. A modifier key is a keyboard
key that modifies rather than printing, such as Ctrl, Alt, or the
Windows key. The makers of Surf believed that Ctrl was the best choice
for MODKEY, and for the most part I concur, but if you're not using the
Windows key for anything else and want to use it for Surf hotkeys, you
can do that by changing the preceding line to the following one:

#+BEGIN_EXAMPLE
  #define MODKEY GDK_SUPER_MASK
#+END_EXAMPLE

Below the preceding line of code is a comment warning you "If you use
anything else but MODKEY and GDK_SHIFT_MASK, don't forget to edit the
CLEANMASK() macro." That warning applies to the modifier mask of a
hotkey record.

Below the warning is the declaration for an array called keys[], which
is an array of a typedef called Key. The following is the definition for
Key, as coded in surf.c:

#+BEGIN_EXAMPLE
  typedef struct {
      guint mod;
      guint keyval;
      void (*func)(Client *c, const Arg *arg);
      const Arg arg;
  } Key;
#+END_EXAMPLE

In other words, each Key element in the keys[] array is a struct
consisting of:

1. Modifier mask, which is the value obtained when OR'ing all modifier
   keys pushed to form this hotkey. In other words, to form
   Shift+Ctrl+r, the modifier mask (mod) would be
   MODKEY | GDK_SUPER_MASK, and the letter (keyval) would be 'r'.
2. The keyboard key (key that inserts something in the output). In other
   words, to form Shift+Ctrl+r, the modifier mask (mod) would be
   MODKEY | GDK_SUPER_MASK, and the letter (keyval) would be 'r', or for
   portability's sake the letter would be GDK_r.
3. A callback function that gets performed when this hotkey is pressed.
4. A generic argument that can be a an int, a boolean, or a pointer to
   void. How this argument is used depends on the callback.

To summarize the preceding several paragraphs, the definition of a
hotkey is an element in the keys[] array consisting of a struct with
elements modifier keys, regular key, callback function, and argument.
This means you can make your own hotkeys by copying other hotkeys and
changing one or more of the four elements. You need to know the GTK
symbols for the keyboard keys, and this info can currently (3/2017) be
found at
[[https://www.rpi.edu/dept/acm/packages/gtk/1.2.10/gtk+-1.2.10/gdk/gdkkeysyms.h]].
You'll probably have a local copy of gdkkeysyms.h, findable with the
following command:

#+BEGIN_EXAMPLE
  find /usr/include | grep gdkkeysyms.h
#+END_EXAMPLE

Here are some hotkeys I added:

1. { 0 , GDK_F2, navigate, { .i = -1 } },
2. { 0 , GDK_grave, navigate, { .i = -1 } },
3. { 0 , GDK_F5, reload, { .b = TRUE } },
4. { 0 , GDK_F6, spawn, SETPROP("_SURF_URI", "_SURF_GO") },
5. { MODKEY, GDK_e, loaduri, { .v = HOMEPAGE } },

In the preceding, #1 goes back to the last viewed page (like a back
button) when the user presses F2. #2 does the same thing when the user
presses the grave accent (`. Both of these aid the mouse user in doing
the back function without dropping the mouse and assuming a full home
key typing position. #3 gives Surf the same reload hotkey as Firefox,
Chromium, Palemoon and the like. #4 partially replicates the F6 action
of major browsers and brings up the URL field. #5 needs a discussion of
its own...

*** Creating a home-page hotkey
    :PROPERTIES:
    :CUSTOM_ID: creating-a-home-page-hotkey
    :END:

Theoretically a tabbed surf session should go to the last argument given
to the surf command, as should each newly-invoked tab. Sometimes, when
you use the surf-open.sh script from a browser, email client or irc
client that doesn't happen just right. Also, sometimes on an already
navigated tab you just want to go right to your home page. So you need
to define a home page and key combo to make that happen. The key combo
is easy: Just place the following line toward the bottom of the rest of
your hotkey definitions in Surf's config.h:

#+BEGIN_EXAMPLE
  { MODKEY,               GDK_z,      loaduri,   { .v = HOMEPAGE}},
#+END_EXAMPLE

The only remaining task is that constant HOMEPAGE is undefined. No
problem. Go up in config.h, and just before the definition of SETPROP,
insert the following three lines, surrounded on top and on the bottom
with blank lines:

#+BEGIN_EXAMPLE
  /* Steve Litt additions */
  #define HOMEPAGE "http://192.168.100.2/littlinks.html"
  /* End of Steve Litt additions */
#+END_EXAMPLE

Obviously, you'll change the string assigned to HOMEPAGE to the URL of
whatever you'd like as your home page.

One more task remains: You really need the go-to-homepage functionality
accessible via the mouse too. So, at the bottom of all the mouse click
definitions at the bottom of config.h, insert the following:

#+BEGIN_EXAMPLE
    { ClkAny,       MODKEY,     1,      loaduri,       { .v = HOMEPAGE } },
#+END_EXAMPLE

The preceding makes left Ctrl+leftclick go to the home page. Obviously,
you'll change the string assigned to HOMEPAGE to the URL of whatever
you'd like as your home page. The following shows it assigned to
http://192.168.100.2/littlinks.html. That page is a hierarchy of links
that I keep up. Obviously, you'll assign it to the home page of your
choice. Insert the following code, surrounded on both ends by a blank
line, modified to represent your desired web page, right above the
definition of SETPROP:

#+BEGIN_EXAMPLE
  /* Steve Litt additions */
  #define HOMEPAGE "http://192.168.100.2/littlinks.html"
  /* End of Steve Litt additions */
#+END_EXAMPLE

Now, every time you press Ctrl and then left click on the browser, your
desired home page is displayed.

** To Plugin, or Not to Plugin?
   :PROPERTIES:
   :CUSTOM_ID: pluginornot
   :END:

There are certain corner cases, involving variables such as distro,
build, webkit build, perhaps which plugins are installed, and which
website you're looking at, that can cause Surf to abort with no useful
message either in the Surf window or in the terminal from which Surf was
invoked. Judging from the fact that Midori, Xombrero and Luakit exhibit
this same intermittent problem but Chromium, Palemoon and Firefox do
not, I suspect it's a Webkit thing, and only on certain distros (I'm
seeing it on Void, but my friends with Devuan don't see it). Luckily,
Surf gives you an easy way to work around this corner case problem.

It turns out that if you turn off plugins in Surf, you turn off this
corner case problem. This is why, throughout this document, I've
recommended using the -p option to Surf: -p turns off plugins. If you
find it hard to remember to use this option in every shellscript and
every command you type, you have the alternative of turning off plugins
in the surf command itself, by making a small change within config.h.
Find the following line:

#+BEGIN_EXAMPLE
  static Bool enableplugins         = TRUE;
#+END_EXAMPLE

Change the TRUE to FALSE, recompile and reinstall. Now, when you run the
surf command, Surf operates with no plugins.

** SETPROP(), dmenu and URL Font
   :PROPERTIES:
   :CUSTOM_ID: setpropdmenu
   :END:

Why, oh why do developers assume the user has 20/20 vision?

Surf uses dmenu to acquire URLs and search screens from the user, and
unfortunately, dmenu ships from Suckless Tools with a rather small and
thin 10 point non-bold monospace font. It ships with non-contrasty
colors: Normal video foreground is #bbbbbb (semi-light gray) on #222222
(very dark gray). The selected video is also less than ideal at #eeeeee
on #005577. If you fall short of 20/20, it's hard to see what you're
typing or what the default is.

My dmenu comes from the package manager, so I can't change the colors by
dmenu compilation. But I can sure change them by dmenu arguments, and
that's what I do in the SETPROP() macro. I take the following line:

#+BEGIN_EXAMPLE
   "| xargs -0 printf %b | dmenu`\" &&" \
#+END_EXAMPLE

I strongarmed the colors to high contrast by adding arguments to the
dmenu call:

#+BEGIN_EXAMPLE
   "| xargs -0 printf %b | dmenu -nf '#ccffff' -nb '#000000' -sf '#000000' -sb '#ffffff'`\" &&" \
#+END_EXAMPLE

Notice the singlequotes around the argument values. Don't use
doublequotes. Don't go entirely without quotes. Use single quotes
because that's what works. Now, about the meaning of these options:

- -nf   Normal foreground
- -nb   Normal background
- -sf   Selected (highlighted) forground
- -sb   Selected (highlighted) background

You might decide to use one other dmenu option: -fn, the font. It's
normally not a good idea to enlarge fonts, but if increased contrast
doesn't work, or the fonts are obviously microscopic, you might have to.
Occasionally microscopic fonts are due to a delusional developer who
thinks the world shares his 20/10 vision, but most of the time they
occur due to a "no such font" situation. In these cases, you need to
specify the font.

Finding the designation of a workable font can be an exhausting trudge
of trial and error through the lands of fonts.alias, xfontsel, and
shortcut names like 10x20.

Fortunately, there's a reliable designation that works with whatever
fonts you happen to have installed on your computer. It consists of a
family designation that is either "sans", "serif" or "monospace",
followed optionally by one or more key/value pairs describing the font
appearance. The following is a comically large example:

#+BEGIN_EXAMPLE
  echo Hello world | dmenu -fn monospace:size=24:weight=bold:slant=italic
#+END_EXAMPLE

In the preceding command, first notice the fact that /all/ characters
are lower class. Keep everything lowerclass in the -fn specification.
It's true that you can sometimes get away with uppercase letters in the
values of some of the key/value pairs, but those cases aren't
determinate or logical or easy to describe. Keeping everything lowercase
keeps everything working. And remember, the font family designation must
always be one of the following three:

- monospace
- sans
- serif

The following is a practical line for the dmenu command within Surf:

#+BEGIN_EXAMPLE
  dmenu -nf '#ccffff' -nb '#000000' -sf '#000000' -sb '#ffffff' -fn 'sans:size=14:weight=bold'
#+END_EXAMPLE

[[file:surf_dmenu_modified_cmd.txt][click here]] to see the entire line.

Referring to the preceding command, if you wanted to make it bold
without changing the size, simply remove :size=14 from the string. In
other words, remove one colon and the size specification. Making fonts
bigger often causes geometric problems, but making fonts bold, which
usually helps readability immensely, has very little downside.

* Installing Tabbed
  :PROPERTIES:
  :CUSTOM_ID: installingtabbed
  :END:

NOTE:

Before doing anything with the Tabbed program, make sure you've compiled
Surf exactly how you want it, and you've installed Surf with its
make install compile command. Make sure also that, if there was also a
package manager created Surf, that you have uninstalled it. When you
work with Tabbed, you want to make sure it's working with the right
version of Surf.

Install the Tabbed package from your package manager. Now run each of
the following commands:

1. tabbed surf -pe
2. tabbed -r2 surf -pe x troubleshooters.com

The preceding are the two different ways to run Surf from Tabbed. The
first way has no home page, so that every new tab is a blank web page.
The second way opens every new tab to a specific web page: Most likely
an HTML list of your favorite links. Each way has pros and cons.

Method #2 is a big productivity boost if you have an excellent HTML
links page maintained up to date. Method #1 enables you to use the
Ctrl+T key combo to open a new tab and specify its URL in one step, and
also, #1's command syntax is much easier to remember and more
explainable. So choose one of the two methods and run Surf under Tabbed.
A list of Tabbed hotkeys follows:

- Shift+Ctrl+Enter: New tab
- Shift+Ctrl+l: Next higher number tab
- Shift+Ctrl+h: Next lower number tab
- Ctrl+Tab: Toggle between last 2 tabs
- Ctrl+1: Switch to tab 1
- Ctrl+2: Switch to tab 2
- Ctrl+3: Switch to tab 3, etc.
- Ctrl+q: Close this tab
- Ctrl+t: Tab picklist

Spend some time operating Surf through Tabbed. See how you like it.
Notice that if you're running without a home page, when you use Ctrl+T,
you can just type in your new URL and press Enter, and the new tab will
show that URL's page. Make sure to use the Ctrl+T tab picklist several
times, and decide whether its font and contrast are appropriate for you.
If not, you'll need to modify Tabbed, a subject covered later in this
document. Look at the thin black strip above the content and below the
titlebar (if you have a titlebar) and note the font and contrast of
writing on it. Is that writing legible enough not to slow you down? If
not, you'll need to modfy Tabbed.

There's a whole [[#modtabbed][section on modifying Tabbed]], but first
let's look at the command used to run Surf under Tabbed...

* Explanation of Commands
  :PROPERTIES:
  :CUSTOM_ID: cmdexpl
  :END:

The command to run Surf under Tabbed without a home page is as follows:

#+BEGIN_EXAMPLE
  tabbed surf -pe
#+END_EXAMPLE

In the preceding -p is necessary in order to prevent plugins. In some
situations (such as my Void Linux installation), running Surf with
plugins allowed sooner or later results in the dread Webkit "quick
vanish" problem. The e in -pe means "parent this Surf to the window ID
after the e. Of course, there's no window ID after the e, so the plot
thickens. The deal is, Tabbed places the window ID at the end of the
entire command, so things work out. But if you try to add a home page
using the following command, it gripes about not being able to find a
web page with a long numeric URL:

#+BEGIN_EXAMPLE
  ###### THE FOLLOWING IS WRONG!!! ######
  tabbed surf -pe troubleshooters.com
#+END_EXAMPLE

The preceding throws an error resembling "Problem occurred while loading
the URL http://134217731/". That number (and your number will be
different and may change from time to time) is the window ID. The
explanation is that the tabbed command bolted the window ID at the end
of the surf command. Having the window ID at the end of the command
causes failure because, when using the -e option, surf uses its very
last argument as the website to look up, but Tabbed appends the window
ID at the end.

What you really need is the following:

#+BEGIN_EXAMPLE
  tabbed surf -pe <windowID> troubleshooters.com
#+END_EXAMPLE

But you can't do that because you don't know the window ID ahead of
time. Right? Well, it turns out you /can/ do that, though indirectly.
Read the part of the Tabbed man page dealing with the -r option...

The -r option specifies the number of the argument of the /surf/ command
to replace with the window number. Notice I said the number of the
argument of the /surf/ command, not the number of the argument of the
Tabbed command. The reason the man page uses the word "command" instead
of "surf" is that Tabbed works with several other programs to give them
tabs. Just keep in mind that a Tabbed command generically looks like the
following:

#+BEGIN_EXAMPLE
  tabbed  <tabbedoptions>  <command>  <command options> 
#+END_EXAMPLE

The -r option for tabbed refers to the argument of <command>

Remember, what you need is the equivalent of:

#+BEGIN_EXAMPLE
  tabbed surf -pe <windowID> troubleshooters.com
#+END_EXAMPLE

To achieve that aim, do the following:

#+BEGIN_EXAMPLE
  tabbed -r 2 surf -pe x troubleshooters.com
#+END_EXAMPLE

The preceding puts the letter "x" as a placeholder for the window ID,
and then uses the tabbed -r option to specify that Surf's arg 2 gets
replaced with the window ID. Well, Surf's arg2 is the "x" placeholder.
Try it: It works.

* Modifying Tabbed
  :PROPERTIES:
  :CUSTOM_ID: modtabbed
  :END:

To modify Tabbed, you need to download its source tarball (.tgz) file,
untar, modify its config.h, and compile. Here's a good compile/run
script to use until you get it just right:

#+BEGIN_EXAMPLE
  #!/bin/sh
  cd ~/compiles/tabbed-0.6
  rm -f ./tabbed
  make clean
  make
  ./tabbed -r2 surf -pe x
#+END_EXAMPLE

Repeatedly modify config.h and run the preceding shellscript until
Tabbed works just how you want, then perform the following:

#+BEGIN_EXAMPLE
  su -c "make install"
#+END_EXAMPLE

Or if you're on one of those distros that depends on sudo,

#+BEGIN_EXAMPLE
  sudo make install
#+END_EXAMPLE

The preceding paragraphs covered the compile part of modifying Tabbed.
Now for the questions "how" and "why?" From my perspective, the hotkeys
of Tabbed are good and useful, so the only reason I'd want to modify the
default is fonts and colors. Tabbed writes in two places:

- Dmenu tab picklist when you press Ctrl+T
- The tab strip on the browser

If the dmenu picklist isn't readable enough for you, perform the same
steps on it that you did when [[#setpropdmenu][the dmenu URL acquirer
field with the SETPROP() macro]].

I find Tabbed's as-shipped colors for the tab strip unfortunate. When
seeing what tab you're on, or what tab you want to move to, the
difference between current and other tabs must be obvious at a glance.
As shipped from Suckless Tools, the current tab is #ffffff on #555555,
and the non-current tabs at #cccccc on #222222. This is not glanceable,
and in fact these two gray-on-grays aren't even easy to read, let alone
glance. And the tiny font is reedy -- it would be much better if it were
bold. I'm not going to tell you what colors to use, but if you want to
gain the full utility of tabs, change the colors so the text is readable
and it's obvious at a glance which tab is current. If you want to follow
my advice and make the tabs font bold, perform the following:

- Change static const char font[] =
  "-*-*-medium-*-*-*-14-*-*-*-*-*-*-*";
- becomes static const char font[] = "-*-*-bold-*-*-*-14-*-*-*-*-*-*-*";

* Mouse-primary Surf Usage
  :PROPERTIES:
  :CUSTOM_ID: mouseprimary
  :END:

As it ships from the factory, Surf is more mouse-friendly than you'd
initially imagine. Obviously, you can click on links, just like any
other browser. You can turn the mouse wheel to scroll a little, or you
can drag the scrollbar to scroll a lot. Right clicking on a web page's
background brings up a menu from which you can go back (like a
backbutton), go forward, or reload the page. If your mouse has buttons 8
and 9, then button 8 is already configured to go back (like a
backbutton) and button 9 is configured to go forward. If you're using
Tabbed, the mouse wheel on the thin black horizontal tab menu cycles
through your tabs. You can also left click on a specific tab in the tab
menu to choose that tab. Middle-clicking on the text of a tab closes
that tab. Here's a summary:

- LEFT click on LINK = go to that link
- LEFT click on TAB TEXT = go to that tab
- Ctrl + LEFT click on LINK = go to that link in a new browser outside
  of Tabbed
- CENTER click on LINK = go to that link in a new tab
- Ctrl + CENTER click on LINK = go to that link in a new browser outside
  of Tabbed
- CENTER click on TAB TEXT = close that tab
- BUTTON8 click in BROWSER = go backwards in history
- BUTTON9 click in BROWSER = go backwards in history
- WHEEL scroll in BROWSER = scroll the web page
- WHEEL scroll in TAB AREA = rotate through tabs

About the only common browser functionalities not included in the
preceding list are opening a new tab and acquiring a new URL (like
Ctrl+g). You can add those functionalities if you want. Once you add
them, the only thing you'll need the keyboard for is typing in a URL,
and that's something that's never going to be done efficiently with a
mouse.

** Acquiring a New URL With the Center Mouse Button
   :PROPERTIES:
   :CUSTOM_ID: acquiring-a-new-url-with-the-center-mouse-button
   :END:

In the Surf window itself, as opposed to the Tabbed strip, you want the
mouse's center button to acquire a URL and display that page, exactly
like Ctrl+g does. It seems easy enough to do within config.h, by adding
the following mouse button record at the bottom of all the other mouse
button records defining the buttons[] array:

#+BEGIN_EXAMPLE
  { ClkDoc,       0,          2,      spawn,  SETPROP("_SURF_URI", "_SURF_GO") },
#+END_EXAMPLE

The ClkDoc means "clicked anywhere on the document. It would override
middle click of a link if it were above the line specifying middle click
in a link, but because it's lower down in the buttons[] array, and the
array is looped through top to bottom, middle button on a link does
what's specified for middle click on a link. When adding keystrokes
and/or mouse strokes, always be careful about order, because both are
read and executed in order.

The good news is, the preceding addition enables the middle mouse button
on an unpopulated area of the browser window to perform the "acquire URL
and go there" functionality. The bad news is that unless you've already
used Ctrl+g to do that on this particular window, it acquires the URL
but doesn't go there, and if you're watching the stdout on the terminal
from which you ran Surf, you'll see an error saying "xprop: error:
Invalid window id format: _SURF_URI." So the user must do a per-tab
intervention to make the middle mouse button acquire and go. That's
inexcusable.

Given that the window id format is wrong only before acquire and go have
been used successfully, it seems likely to be a window id initialization
problem. Looking at all the functions in surf.c, just by name function
updatewinid() seemed likely to be involved. Searching all occurrences of
updatewinid() revealed that updatewinid() is called from the kepress()
function, but not by its mouse counterpart, buttonrelease(). Indeed,
commenting out updatewinid() within keypress() created the exact same
error on pressing Ctrl+g. The updatewinid() function occurs just before
the for loop in keypress(), so I put one just above the for loop in
buttonrelease(), and /bang/, the problem went away.

So to complete your installation of middle mouse button bringing up
acquire and goto URL, place the following line immediately above the for
statement in function buttonrelease:

#+BEGIN_EXAMPLE
    updatewinid(c);
#+END_EXAMPLE

So, placing one line in config.h and one in surf.c adds the
functionality.

One more thing. I've never maintained this code, and I'm not as good a
developer as the person who does, but I have a strong hunch that leaving
out the updatewinid() in function buttonrelease() was an oversight,
given the design resemblance of updatewinid() to keypress(). However,
it's also possible that my insertion of the call to updatewinid() could
cause side effects, perhaps even a security flaw. You need to ask more
knowledgeable people than me about that.

** Making Ctrl+leftclick bring up the assigned home page
   :PROPERTIES:
   :CUSTOM_ID: making-ctrlleftclick-bring-up-the-assigned-home-page
   :END:

Add the following code to the bottom of the mouse action list:

#+BEGIN_EXAMPLE
    { ClkAny,       MODKEY,     1,      loaduri,
  { .v = HOMEPAGE } },
#+END_EXAMPLE

The preceding makes left Ctrl+leftclick go to the home page, just as
soon as you define the constant HOMEPAGE. Do that by adding the
following code, surrounded on both sides by a blank line, above the
current definition of SETPROP:

** Making Right Click on the Tab Strip Create a New Tab
   :PROPERTIES:
   :CUSTOM_ID: making-right-click-on-the-tab-strip-create-a-new-tab
   :END:

To complete your mouse-centric functionality, you need to be able to
create new tabs with the mouse. You'll enable a right mouse click
anywhere on the Tab strip to create a new tab. You'll do this in
tabbed.c, not in its config.h include file.

Edit tabbed.c search for function buttonpress(), and look for its for
loop. Within the for loop is an if statement, which itself contains a
switch statement. The switch statements has cases for buttons 1, 2, 4
and 5. The right mouse button is button 3, so go ahead and add its case
between the cases for buttons 2 and 4, as follows:

#+BEGIN_EXAMPLE
      case Button3:
        focusonce(i);
        spawn(i);
        break;
#+END_EXAMPLE

Recompile and enjoy your new right click on tab strip creates new tab
feature.

My advice to edit tabbed.c goes against the Suckless Tools philosophy,
which maintainst that all user changes should happen in the config.h
file. But in this case, the only way to do it is in the tabbed.c file,
because unlike the Surf source code, Tabbed doesn't maintain an array of
possible mouse events in its config.h, but instead hard codes responses
to mouse events within tabbed.c.

* Integrating Tabbed and Surf With Other Programs
  :PROPERTIES:
  :CUSTOM_ID: integration
  :END:

The guys from Suckless Tools are quite clever. In the Surf distribution,
they give you a shellscript called surf-open.sh which your email and IRC
clients and other programs can call just the same way they call Firefox
or Chromium, and if Tabbed is running, the desired website becomes one
more tab. If Tabbed isn't yet running, surf-open.sh starts Tabbed with a
tab showing the requested URL. Behold the power of minimalism: They've
built Tabbed and Surf as tiny tools that do one thing and do it well, so
that with their 32 line shellscript surf-open.sh Surf can act like the
bigshot browsers.

Danger!

If your installation intermediately exhibits the dreaded webkit "browser
program vanishes" symptom, you must either change every -e to -pe in
surf-open.sh, or you must configure Surf to [[#pluginornot][start
without plugins]].

Running make install doesn't automatically put surf-open.sh on your
path, so you need to copy it to a location on your path.

The final step is to tell your other programs to use surf-open.sh as
your browser.

Clicking a URL in an email or IRC post and having it show up in the one
and only Tabbed program might not be your cup of tea, especially if you
make heavy use of workspaces. Sometimes you don't want to hunt for your
browser: You want it to pop right up, even if it's a separate window
adding to the mess. If this paragraph describes you, then instead of
using surf-open.sh for the application's browser, use surf -p.

* The Suckless Tools Advantage
  :PROPERTIES:
  :CUSTOM_ID: sucklessadvantage
  :END:

The [[#mouseprimary][preceding article]] showcases one of the Suckless
Tools advantages: The fact that a mere mortal can actually change it.
Now I'm not average: I spent 15 years as a professional developer, ten
of which I spent doing C. So I can read well written code, and I used
that ability to look over the less than 4000 lines of Surf plus Tabbed
code to figure out what to do. Now imagine me doing the same thing on
Firefox. Or Libreoffice. Or systemd. I'd spend a half hour scanning the
more than a hundred thousand lines of code, give up in frustration, and
either use something from Suckless Tools or write my own.

Suckless Tools makes their software short, simple, organized, and well
commented. Suckless Tools programs have no runtime config files.
Instead, ordinary config changes can be done by non-programmers in the
config.h program, using the well laid out comments and matrix like
arrays of structs, and then compiled. Even fixing flaws in their program
or adding features not anticipated (like right click makes new tab) are
quite doable by someone who knows a little C, because in almost every
case you can compare and contrast similar code (such as keypress() vs
buttonrelease() or making a copy of an existing mouse event array
element and changing its button and callback function and args). The
folks at Suckless Tools have written their software to be modified by
mere mere mortals, and they've succeeded mightily.

An often stated benefit of Free Software is if you don't like it, you
can change it. Of course, this is usually propaganda. I don't like
systemd, but I don't have the tech chops to modify udev to not depend on
systemd. Both udev and systemd are maintained by paid teams, not by one
guy, as far as I know. But with Suckless Tools software, one guy really
can change them.

And speaking of systemd, did you know that Suckless Tools offers
Suckless Init, an 83 lines of C program that acts as PID1 and can be
combined with daemontools-encore to make a complete init system that
yes, a mere mortal /can/ understand? They created dmenu, the greatest
small software component ever produced: You can use it to acquire
choices and text throughout all your software and shellscripts.

From Suckless Tools, you can get a lightweight terminal called st, a
lightweight but supposedly efficient shell called mksh, a reliable
screen locker called slock, a complete tiled window manager called dwm,
assembled from Suckless Tools and other simple software, a Plan 9
toolset called 9base, and lots more. If you're a DIY software person who
likes bolting software together, Suckless Tools is a treasure trove.

It's no accident that the Suckless Tools project has created arguably
the most stable and productive browser. The Suckless Tools project
operates according to a philosophy that almost guarantees minimal bugs,
minimal unexpected behavior, minimal negative interaction with other
software, and maximum ability to mix and match its tools into the system
of your choice, as long as stability and performance are prioritized
above "pretty."

For starters, Suckless Tools programs are kept short. Surf's source code
is less than 2000 lines, assuming you're not counting the code within
Webkit and GTK. The Tabbed program has less than 1500 lines of source.
The dmenu program has less than 1300 lines. The three of them fit
together to make a tabbed browser with user input acquisition and a menu
of tabs provided by dmenu. Both Tabbed and dmenu are designed from the
bottom up to be generic tools.

For instance, Tabbed can be used to provide tabs for non-tabbed
programs. Ever want a tabbed version of xterm? The following command
gives it to you:

#+BEGIN_EXAMPLE
  tabbed xterm -into
#+END_EXAMPLE

I never before used urxvt because of its lack of tabs and tiny fonts.
The following solves both problems:

#+BEGIN_EXAMPLE
  tabbed -g 900x600 urxvt  -fn xft:mono:size=10:weight=bold  -embed
#+END_EXAMPLE

Careful!

If you use Tabbed's -g geometry option, you can't resize its window in
the window manager, either by dragging corners or by clicking the
maximize button. Over the long haul, you might be happier not specifying
-g, and adjusting manually.

The dmenu program is known far and wide as the ultimate GUI picklist and
input field tool, easily used with lots of other programs. It's also a
trivial way for you to acquire user input in your programs and
shellscripts. Many people use it hundreds of times daily to run
programs. Dmenu is the great window manager equalizer, rendering the
window manager's menu and other program running features moot. If you
need to write a quick and dirty application, dmenu is your friend. You
can integrate dmenu with any software that can receive input from a
shellscript.

Complexity reduction is a top priority with Suckless Tools. The Suckless
Tools project realizes that complexity is costly, in terms of providing
nooks and crannies for bugs to hide, in terms of difficulty making
changes, in terms of understanding how the program works, and in terms
of performance.

A part of complexity reduction is keeping dependencies to a minimum. In
this Freedesktop.Org, Redhat, Systemd "age of integration", an age in
which the word "encapsulation" has been forgotten, it's a pleasure to
work with small executables with thin interfaces that can be assembled
into any software you desire, at the shellscript level, via those thin
interfaces.

** A New Age of DIY?
   :PROPERTIES:
   :CUSTOM_ID: a-new-age-of-diy
   :END:

There was a time when Linux was, by necessity, DIY. As time went on, it
became ever less so, opening Linux to a wider and wider audience. But
from my viewing angle, the march away from DIY went too far. Browser are
now feature-packed, or, as I view it, feature-encumbered, so today
they're slow, crashy, and always surprising. OS level user interfaces
like KDE, Gnome and Unity constantly get in the way, often perceptibly
slowing fast machines, and making moderate machines crawl. Now the Xfce
desktop environment is following in their footsteps. Gnome now cares
what init system you use: Modern Gnome runs only on computers initted
with systemd. Huh? Six or seven years ago the Kmail email client got so
complex as to be almost unuseable. Now Thunderbird can take hours to
sync up with an IMAP server /on the same computer/.

Much of this bloatware is created by tight compile-time binding with
many libraries, via thick and complex interfaces. If one of the
libraries gets a bug, the software using it becomes buggy too. Good
software gone bad: Who hasn't experienced switching from one to another
to another and back again in a category of software, as various programs
stop doing what's needed or start acting erratic?

And then there are the "great new ideas" from the developers, each one
requiring you to substantially alter your work flow, which is pretty
funny, considering that your original workflow was probably modeled to
accommodate your workarounds for applications that were procedurally or
ergonomically inefficient. Some free software library developer decides
it would improve his career to re-code his creation in Newfad.js plus
Object Haskell, and now /you/ need to change your work habits and even
your shellscripts.

DIY stands for *Do* *I*t *Y*ourself. The alternative to DIY is HIDTY:
*H*ave *I*t *D*one *T*o *Y*ou. With HIDTY, some developer makes a
decision or mistake, and you have to adapt your habits, or perhaps go
searching for different software. It happens over and over again. HIDTY
is the way of life of the Windows user. Over the years, HIDTY has
presented us with ever more complex software on Linux.

Till recently, HIDTY has been the exclusive trend on Linux. Those with
mental blocks against shellscripting and simple Pythoning had no choice
but HIDTY, and even programmers went with HIDTY with explanations like
"I don't have time to program my machine." But lately, HIDTY fiascos
like Kmail2 and systemd have caused those with programming chops to
change that mantra to "I don't have time to adapt to every experiment
these devels decide to do." In the past three to five years, more than a
few computer users have gone DIY, opting for simple software that does
one thing and does it well, freeing them from playing catch-up with the
latest version of bloatware.

And more and more, this new group of DIY computer users is discovering
Suckless Tools.

* Surf: An Acquired Taste
  :PROPERTIES:
  :CUSTOM_ID: acquiredtaste
  :END:

I doubt anybody envisions Surf when discussing browsers. But as you get
used to it, you appreciate it. You appreciate its productive keyboard
interface. For me, Surf started out as a refuge to the problems I was
having with Firefox, Palemoon and Chromium. Surf meant settling for less
than my ideal just to get stability and performance. But as I got used
to it, I began to appreciate its efficient use of screen real estate and
its stability, even on crazy sites. I appreciate its
keyboard-centricity, without giving up efficient mousery. I appreciate
the superb way it handles Youtube videos. And finally, I fell in love
with the way I can program it with whatever features /I/ want.

When you switch to Surf, be aware that you can't truly evaluate it until
you've been using it as your primary browser for a week. And even then,
you can't really evaluate it unless you've configured it to meet /your/
needs.

* Wrapup
  :PROPERTIES:
  :CUSTOM_ID: wrapup
  :END:

In the last few years, mainstream browsers have declined in performance
and stability to the point where people are willing to sacrifice
features for stability and performance, bringing a new relevance to the
Surf browser from Suckless Tools. Surf devotes all its screen real
estate to the web page under examination. Surf is remarkably well suited
to control via the keyboard. This document has shown you how to compile
your own Surf in order to have a user interface that exactly matches
your way of working. In the hands of someone unafraid of changing a
little C code, Surf is a browser custom made to you. This has been a
very long document because this document is the most complete
documentation of Surf on the planet. Bookmark this document.

If you've been falling out of love with Firefox, Chromium, Palemoon,
Qupzilla and the crew, you owe it to yourself to investigate Surf. If
you've begun feeling uneasy with big software that frequently stops
working, be sure to investigate [[http://suckless.org][Suckless Tools]].

--------------

[ [[../utp/tcourses.htm][Training]] |
[[../troubleshooters.htm][Troubleshooters.Com]] |
[[../email_steve_litt.htm][Email Steve Litt]] ]

\\


